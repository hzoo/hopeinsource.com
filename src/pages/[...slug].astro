---
import { getCollection, render } from "astro:content";
import Layout from "@/layouts/Layout.astro";
import EpisodeSidebar from "@/components/EpisodeSidebar.astro";
import TableOfContents from "../components/TableOfContents.astro";
import AudioPlayer from "@/components/AudioPlayer.astro";
import Footer from "@/components/Footer.astro";
import Subscribe from "@/components/Subscribe.astro";

export async function getStaticPaths() {
  const podcastEntries = await getCollection("podcast");

  // Sort episodes same as Main.astro/EpisodeSidebar.astro
  const sortedEntries = [...podcastEntries].sort((a, b) => {
    const aSeason = a.data.season || 0;
    const bSeason = b.data.season || 0;
    if (bSeason !== aSeason) {
      return bSeason - aSeason;
    }
    return b.data.sidebar.order - a.data.sidebar.order;
  });

  // Compute episode numbers (last in sorted list = #1)
  const episodeNumbers = new Map(
    sortedEntries.map((entry, index) => {
      const slug = entry.id.split("/").pop() || "";
      return [slug, sortedEntries.length - index];
    })
  );

  // Pre-render content at build time
  const pages = await Promise.all(
    podcastEntries.map(async (entry) => {
      const slug = entry.id.split("/").pop() || "";
      const { Content, headings } = await render(entry);
      const h4Headings = headings.filter((h) => h.depth === 4);

      return {
        params: { slug },
        props: {
          slug,
          Content,
          headings: h4Headings,
          frontmatter: entry.data,
          episodeNumber: episodeNumbers.get(slug || "") || 0,
        },
      };
    }),
  );

  return pages;
}

const { slug, Content, headings, frontmatter, episodeNumber } = Astro.props;

// Parse title to separate episode name from guest
function parseTitle(title: string): { episodeTitle: string; guest: string | null } {
  const match = title.match(/^(.+?)\s*\(([^)]+)\)$/);
  if (match) {
    return { episodeTitle: match[1].trim(), guest: match[2].trim() };
  }
  return { episodeTitle: title, guest: null };
}

const { episodeTitle, guest } = parseTitle(frontmatter.title);
---

<Layout frontmatter={frontmatter} slug={`/${slug}`}>
  <EpisodeSidebar currentSlug={slug} headings={headings} />

  <div class="lg:ml-80">
    <div class="mx-auto px-3 sm:px-4 py-6 sm:py-8 flex flex-col lg:max-w-4xl">
      {/* Episode header */}
    <header class="text-center mb-4">
      <h1 class="text-2xl md:text-3xl font-semibold mb-1">{episodeTitle}</h1>
      {guest && <p class="text-his-text-secondary mb-2">{guest}</p>}
      <div class="flex items-center justify-center gap-2 text-sm text-his-text-tertiary">
        <time datetime={frontmatter.date.toISOString()}>
          {frontmatter.date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
          })}
        </time>
        {frontmatter.time && (
          <>
            <span class="text-his-text-tertiary/50">·</span>
            <span>{frontmatter.time} min</span>
          </>
        )}
        {episodeNumber > 0 && (
          <>
            <span class="text-his-text-tertiary/50">·</span>
            <span class="text-his-green/70">#{episodeNumber}</span>
          </>
        )}
      </div>
    </header>

    {/* Description as the hook */}
    <p class="text-center text-sm text-his-text-secondary max-w-xl mx-auto mb-3 leading-relaxed">
      {frontmatter.description}
    </p>

    {/* Subscribe as afterthought */}
    <div class="mb-6">
      <Subscribe />
    </div>

    <TableOfContents headings={headings} />

    <div class="mx-auto max-w-3xl">
      <main>
        <Content />
      </main>
    </div>
    <Footer />
    <AudioPlayer title={frontmatter.title} src={frontmatter.episodeLink} />
    </div>
  </div>

  {/* Handle message deep-linking with flash animation */}
  <script is:inline>
    function highlightMessage() {
      const hash = window.location.hash;
      if (!hash || !hash.startsWith('#msg-')) return;

      const el = document.getElementById(hash.slice(1));
      if (el) {
        // Small delay to ensure layout is complete
        setTimeout(() => {
          el.scrollIntoView({ block: 'center', behavior: 'smooth' });
          el.classList.add('highlight-flash');
          // Remove class after animation completes
          el.addEventListener('animationend', () => {
            el.classList.remove('highlight-flash');
          }, { once: true });
        }, 100);
      }
    }

    // Run on initial load
    highlightMessage();

    // Run after View Transitions
    document.addEventListener('astro:after-swap', highlightMessage);

    // Handle hash changes (e.g., clicking TOC links)
    window.addEventListener('hashchange', highlightMessage);
  </script>
</Layout>
