---
interface TOCHeading {
  slug: string;
  text: string;
}

interface Props {
  headings: TOCHeading[];
}

const { headings } = Astro.props;
---

{headings.length > 0 && (
  <>
    <!-- Scrubber toggle -->
    <div
      id="toc-scrubber"
      class="fixed left-3 top-1/2 -translate-y-1/2 flex flex-col gap-1.5 p-2 z-40 group cursor-pointer"
      aria-label="Table of contents"
    >
      {headings.map((heading) => (
        <div
          class="toc-scrubber-bar w-3 h-0.5 bg-his-text-tertiary transition-all duration-300 rounded-full group-hover:bg-his-text-secondary"
          data-scrubber-id={heading.slug}
        />
      ))}
    </div>
    
    <!-- Optional subtle backdrop -->
    <div
      id="toc-backdrop"
      class="fixed inset-0 bg-black/20 opacity-0 invisible transition-opacity duration-150 z-40 lg:hidden"
    />
    
    <!-- Table of contents overlay -->
    <nav
      id="toc-nav"
      class="fixed left-12 top-1/2 w-64 max-h-[80vh] bg-his-bg border border-his-hr rounded-lg shadow-xl opacity-0 invisible transition-all duration-300 z-50 overflow-y-auto"
      style="transform: translateY(-50%) translateX(-10px);"
    >
      <div class="p-2">
        <div class="flex items-center justify-between border-b border-his-hr/50 pb-2 mb-2">
          <h3 class="text-[10px] font-bold uppercase tracking-[0.2em] text-his-text-tertiary px-2.5">Contents</h3>
          <button
            id="toc-close"
            class="text-his-text-tertiary hover:text-his-text transition-colors p-1"
            aria-label="Close table of contents"
          >
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
              <path d="M18 6L6 18M6 6l12 12" />
            </svg>
          </button>
        </div>
        <ul class="list-none p-0">
          {headings.map((heading) => (
            <li class="mb-0.5">
              <a
                href={`#${heading.slug}`}
                class="toc-link block rounded-md text-sm no-underline transition-all duration-200 hover:bg-his-hover py-2 px-2.5 text-his-text-secondary hover:text-his-text"
                data-heading-id={heading.slug}
              >
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </div>
    </nav>
  </>
)}

<script>
  let currentActiveId: string | null = null;
  
  const tocScrubber = document.getElementById('toc-scrubber');
  const tocBackdrop = document.getElementById('toc-backdrop');
  const tocNav = document.getElementById('toc-nav');
  const tocClose = document.getElementById('toc-close');
  const tocLinks = document.querySelectorAll('.toc-link');
  const scrubberBars = document.querySelectorAll('.toc-scrubber-bar');

  function setActive(id: string) {
    if (currentActiveId === id) return;
    currentActiveId = id;

    // Update overlay links
    tocLinks.forEach(link => {
      const linkId = link.getAttribute('data-heading-id');
      if (linkId === id) {
        link.classList.add('active');
        link.classList.add('text-his-green');
      } else {
        link.classList.remove('active');
        link.classList.remove('text-his-green');
      }
    });

    // Update scrubber bars
    scrubberBars.forEach(bar => {
      const barId = bar.getAttribute('data-scrubber-id');
      if (barId === id) {
        bar.classList.add('bg-his-green');
        bar.classList.add('w-5');
        bar.classList.remove('bg-his-text-tertiary');
      } else {
        bar.classList.remove('bg-his-green');
        bar.classList.remove('w-5');
        bar.classList.add('bg-his-text-tertiary');
      }
    });
  }

  function openTOC() {
    if (window.innerWidth < 1024) {
      tocBackdrop?.classList.remove('invisible', 'opacity-0');
      tocBackdrop?.classList.add('opacity-100');
    }
    tocNav?.classList.remove('invisible', 'opacity-0');
    tocNav?.classList.add('opacity-100');
    // Shift the nav in slightly
    tocNav?.style.setProperty('transform', 'translateY(-50%) translateX(0)');
  }

  function closeTOC() {
    tocBackdrop?.classList.remove('opacity-100');
    tocBackdrop?.classList.add('invisible', 'opacity-0');
    tocNav?.classList.remove('opacity-100');
    tocNav?.classList.add('invisible', 'opacity-0');
    tocNav?.style.setProperty('transform', 'translateY(-50%) translateX(-10px)');
  }

  // Toggle scrubber click
  tocScrubber?.addEventListener('click', () => {
    if (tocNav?.classList.contains('opacity-100')) {
      closeTOC();
    } else {
      openTOC();
    }
  });

  // Close button click
  tocClose?.addEventListener('click', (e) => {
    e.stopPropagation();
    closeTOC();
  });

  // Backdrop click
  tocBackdrop?.addEventListener('click', closeTOC);

  // Click outside to close
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (tocNav?.classList.contains('opacity-100')) {
      if (!tocNav.contains(target) && !tocScrubber?.contains(target)) {
        closeTOC();
      }
    }
  });

  // Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && tocNav?.classList.contains('opacity-100')) {
      closeTOC();
    }
  });

  // Smooth scroll for links
  tocLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const href = link.getAttribute('href');
      if (href) {
        const target = document.querySelector(href);
        if (target) {
          closeTOC();
          setTimeout(() => {
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 100);
        }
      }
    });
  });

  // Intersection Observer for active heading
  // Use a different root margin to detect when the heading reaches the top
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          setActive(entry.target.id);
        }
      });
    },
    { 
      // Look for headings in the top 20% of the viewport
      rootMargin: '-10% 0px -70% 0px',
      threshold: 0
    }
  );

  const headingElements = document.querySelectorAll('h4');
  headingElements.forEach((heading) => observer.observe(heading));

  // Initialize active state based on current scroll position or hash
  window.addEventListener('load', () => {
    const hash = window.location.hash;
    if (hash) {
      const id = hash.replace('#', '');
      setActive(id);
    }
  });
</script> 